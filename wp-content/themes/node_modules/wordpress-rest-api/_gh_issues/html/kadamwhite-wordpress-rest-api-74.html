<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <link rel="stylesheet" type="text/css" href="css/style.css">
    <script type="text/javascript" src="lib/jquery.js"></script>
    <script type="text/javascript" src="lib/jquery.emoji.js"></script>
    <title>Prototype how to populate route templates from top-level routes endpoint</title>
  </head>
  <body>
    <div class="container">
      <header>
        <p>
          <span class="badge open">open</span>
          <span class="url">kadamwhite/wordpress-rest-api#74</span>
        </p>
        <h1>Prototype how to populate route templates from top-level routes endpoint</h1>
      </header>
      <div class="comments">
        <div class="comment">
          <div class="meta">
            <a class="person" href="https://github.com/kadamwhite">kadamwhite</a>
            <time>8/2/2014</time>
          </div>
          <div class="body">
            <p>One major point of discussion at WCNYC surrounding the API is how to handle discoverability, as it was recommended to consider templated URLs (which are common with SAAS-provided APIs) to be an anti-pattern when the WP ReST API can be considered to be more of an API <em>builder</em> for individual sites than an API in and of itself. In a polymorphic world of individually-configured and customized WordPress installs, having non-templated paths that are all discovered from a root endpoint is the solution deemed most flexible and least likely to paint us into a corner.</p>
<p>Significant drawbacks to this approach:</p>
<ul>
<li><p>A first request is <em>always</em> needed: There is no way to query for a resource without first interrogating the root endpoint for location information. You can safely assume you know how things are set up in most cases, but there&#39;s no way around this added request overhead if you&#39;re requesting content from a third-party site for the first time.</p>
</li>
<li><p>To avoid having to make a first request for <em>all</em> subsequent requests, the information from that request (an object defining available endpoints, from which all following requests will be derived) must be cached somehow. This is of minor concern in server-side applications, which can cache in-memory within the process, in session storage, or persistently in a database; but for client applications this data would need to be persisted in local storage or a similar client-side cache in order to avoid needing to be requested on every page load.</p>
</li>
</ul>
<p>I find this concept appealing from the standpoint of conceptual flexibility, and in the way it forces you to confront resources very specifically as members of collections, but I still can&#39;t but think it would be extremely frustrating and limiting in implementation. I want to study more APIs and figure out if there&#39;s anything out there operating in the fashion described by @maxcutler, to evaluate the best way to work around these limitations and alleviate my concerns.</p>

          </div>
        </div>

        <div class="comment">
          <div class="meta">
            <a class="person" href="https://github.com/kadamwhite">
              kadamwhite
            </a>
            <time>1/29/2016</time>
          </div>
          <div class="body"><p>We can take inspiration from how @adamsilverstein has handled this in WP-API/client-js</p>
</div>
        </div>
      </div>
    </div>

    <script type="text/javascript">
      $(document).ready(function(){
        $('.comment').each(function(i, d){
          $(d).emoji()
        })
      })
    </script>

  </body>
</html>
